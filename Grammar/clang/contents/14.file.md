### [C语言 文件存储操作](#top)  <b id="top"></b>
`文件是操作系统管理数据的基本单位，文件一般是指存储在外部存储介质上的有名字的一系列相关数据的有序集合。它是程序对数据进行读写操作的基本对象。在 C 语言中，把输入和输出设备都看作文件。` 

------

- [x] [`1.文件分类及其说明`](#target1)
- [x] [`2.文件的打开与关闭`](#target2)
- [x] [`3.文件的顺序读写`](#target3)
- [x] [`4.按格式化输入输出`](#target4)
- [x] [`5.按二进制方式读写数据块`](#target5)
- [x] [`6.文件的随机读写`](#target6)

------

#####  [1.文件分类及其说明](#top) <b id="target1"></b> 
`文件一般包括三要素：文件路径、文件名、后缀。` 

```javascript
由于在 C 语言中 '\' 一般是转义字符的起始标志
故在路径中需要用两个 '\' 表示路径中目录层次的间隔，也可以使用 '/' 作为路径中的分隔符。

例如，"E:\\ch10.doc"或者"E:/ch10.doc"
```
`C 语言中的输入和输出都是和文件相关的，即程序从文件中输入（读取）数据，程序向文件中输出（写入）数据。`

`流式文件是以字节为单位，对流式文件的访问一般采用穷举搜索的方式，效率不高，故一般需频繁访问的较大数据
不适宜采用流式文件逻辑结构。但由于流式文件管理简单，用户可以较方便地对文件进行相关操作。`

##### 类别
`根据文件中数据的组织形式的不同，可以把文件分为：文本文件和二进制文件。`

* `文本文件`：`把要存储的数据当成一系列字符组成，把每个字符的 ASCII 码值存入文件中。每个 ASCII 码值占一个字节，每个字节表示一个字符。故文本文件也称作字符文件或 ASCII 文件，是字符序列文件。`
* `二进制文件`：`把数据对应的二进制形式存储到文件中，是字节序列文件。`

##### 说明
`C 程序与文件的访问中，经常涉及换行操作。二进制文件与文本文件在换行规则上略有差别。`

`在 UNIX 和 Linux 系统中，无论是二进制文件还是文本文件，均是以单字节 LF(0x0A) 即作为文件中的换行符。`

`由于 C 语言是在 UNIX 系统上提出并发展起来的，故 C 语言中的换行规则与 UNIX 系统文件中的换行规则是一致的，使用 LF 即 '\n' 表示换行。因此 C 语言程序访问 UNIX/Linux 系统中的文件时，可直接访问，不需要转换。`

##### 缓冲和非缓冲文件系统
`C语言中文件系统可分为两大类，一种是缓冲文件系统也称为标准文件系统，另一种是非缓冲文件系统。ANSI C 标准中只采用缓冲文件系统。`

* `缓冲文件系统`：`系统自动为每个打开的文件在内存开辟一块缓冲区，缓冲区的大小一般由系统决定。当程序向文件中输出（写入）数据时，程序先把数据输出到缓冲区，待缓冲区满或数据输出完成后，再把数据从缓冲区输出到文件；当程序从文件输入(读取)数据时，先把数据输入到缓冲区，待缓冲区满或数据输人完成后，再把数据从缓冲区逐个输入到程序。`
* `非缓冲文件系统`：`系统不自动为打开的文件开辟内存缓冲区，由程序设计者自行设置缓冲区及大小。`

`每个 C 编译系统 stdio.h 文件中的 FILE 定义可能会稍有差别，但均包含文件读写的基本信息。`
##### [2.文件的打开与关闭](#top) <b id="target2"></b> 

##### 文件类型指针
`文件信息是保存在一个结构体变量中的。该结构体类型是由系统定义的，取名为FILE`
```c
#include<stdio.h>

FILE *fp;
```
```c
#ifndef _FILE_DEFINED
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;
#define _FILE_DEFINED
```
##### 打开关闭
`这里的“打开”和“关闭”可调用标准库 stdio.h 中的 fopen 和 fclose 函数实现。`

```c
FILE * fopen(char *filename, char *mode);

int fclose(FILE *fp); /* 返回值：正常关闭，返回否则返回 EOF(-1)。 */
```

|`模式`| 	`含 义`| 	`说 明`|
|:--|:--|:---|
|`r`|`只读 read`|`文件必须存在，否则打开失败`|
|`w`|`只写 write`|`若文件存在，则清除原文件内容后写入；否则，新建文件后写入`|
|`a`|`追加只写 add`|`若文件存在，则位置指针移到文件末尾，在文件尾部追加写人，故该方式不 删除原文件数据；若文件不存在，则打开失败`|
|`r+`|`读写 + = write + read`|`文件必须存在。在只读 r 的基础上加 '+' 表示增加可写的功能。下同`|
|`w+`|`读写`|`新建一个文件，先向该文件中写人数据，然后可从该文件中读取数据`|
|`a+`|`读写`|`在” a”模式的基础上，增加可读功能`|
|`rb`|`二进制读 binary`|`功能同模式”r”，区别：b表示以二进制模式打开。下同`|
|`wb`|`二进制写`|`功能同模式“w”。二进制模式`|
|`ab`|`二进制追加`|`功能同模式”a”。二进制模式`|
|`rb+`|`二进制读写`|`功能同模式"r+”。二进制模式`|
|`wb+`|`二进制读写`|`功能同模式”w+”。二进制模式`|
|`ab+`|`二进制读写`|`功能同模式”a+”。二进制模式`|

```c
#include <malloc.h>
#include <stdio.h>
// 主函数
int main(int argc, char *argv[]) // *argv[]：指针数组
{
  FILE *fp; // 文件指针
  fp = fopen("input.txt","r"); // 打开文件
  read/write fucntions // 读或者写函数
  fclose(fp); // 关闭文件指针

  return 0;
}
```

* `字符读写函数`:` fgetc和 fputc`  
* `字符串读写函数`:` fgets和 fputs`  
* `数据块读写函数`:` freed和 fwrite`  
* `格式化读写函数`:` fscanf和 fprinf`

##### [3.文件的顺序读写](#top) <b id="target3"></b> 
`对文件读取操作完成后，如果从文件中读取到的每个数据的顺序与文件中该数据的物理存放顺序保持一致，则称该读取过程为顺序读取；同理，对文件写入操作完成后，如果文件中所有数据的存放顺序与各个数据被写入的先后顺序保持一致，则称该写入过程为顺序写入。`

##### fgetc 
`c 语言中提供了从文件中逐个输入字符及向文件中逐个输出字符的顺序读写函数 fgetc 和 fputc 及调整文件读写位置到文件开始处的函数 rewind。这些函数均在标准输入输出头文件 stdio.h 中。`

```c
// 字符输入函数 fgetc 的函数原型为：
int fgetc (FILE *fp);

//字符输出函数 fputc 的函数原型为： 
int fputc (int c, FILE *fp);
```

* `fgetc`:`函数功能：从文件指针 fp 所指向的文件中输入一个字符。输入成功，返回该字符；已读取到文件末尾，或遇到其他错误，即输入失败，则返回文本文件结束标志 EOF(EOF 在 stdio.h 中已定义，一般为 -1)。`
* `fputc`:`函数功能：向 fp 指针所指向的文件中输出字符 c，输出成功，返回该字符；输出失败，则返回 EOF(-1)。`

##### rewind
`文件读写位置复位函数 rewind 的函数原型为：`
```c
#include<stdio.h>

void rewind (FILE *fp);
```
`函数功能：把 fp 所指向文件中的读写位置重新调整到文件开始处。`

```c
#include<stdio.h>
#include<stdlib.h>
int main (void)
{
    char file_name[20]="D:/data—file.txt";
    FILE * fp=fopen (file_name, "w") ; //打开文件
    int c; //c:接收fgetc的返回值，定义为int，而非char M
    if(NULL==fp)
    {
        printf ("Failed tO open the file !\n");
        exit(0);
    }
    printf ("请输入字符，按回车键结束：");
    while ((c=fgetc (stdin)) != '\n') //stdin:指向标准输人设备键盘文件
    {
        fputc (c, stdout); //stdout:指向标准输出设备显示器文件
        fputc(c,fp);
    }
    fputc ('\n', stdout);
    fclose (fp); //关闭文件
    return 0;
}
```
##### [4.按格式化输入输出](#top) <b id="target4"></b>  

##### fscanf
`文件格式化输入函数 fscanf 的函数原型为：`
```c
int fscanf (文件指针，格式控制串，输入地址表列);
```
`函数功能：从一个文件流中执行格式化输入，当遇到空格或者换行时结束。注意该函数遇到空格时也结束，这是其与 fgets 的区别，fgets 遇到空格不结束。`

`若文件 f1.dat 中保存了若干整数，各整数之间用空格间隔，从文件中读取两个整数，依次保存到两个整型变量中。程序代码段如下。`
```c
int a,b;
FILE *fp=fopen("f1.dat","r");
if(NULL==fp)
{
    printf ("Failed to open the file!\n");
    exit (0);
}
fscanf (fp,"%d%d",&a,&b) ; //从fp所指文件中读取一个整数保存到变量a中
fclose(fp);
```
`如果 f1.dat 中的整数用逗号间隔，则读取两个整数时，函数 fscanf 的调用格式如下所示。`

```c
fscanf (fp,"%d,%d", &a, &b); //两个%d之间也必须用逗号隔开
```

##### fprintf
`文件格式化输出函数 fprintf 的函数原型为：`
```c
int fprintf (文件指针，格式控制串，输出表列)；
```
* `函数功能`：`把输出表列中的数据按照指定的格式输出到文件中。`
* `返回值`：`输出成功，返回输出的字符数；输出失败，返回一负数。`

`向当前目录文件file.txt中输入一个学生的姓名、学号和年龄，采用文本方式，参考代码如下。`
```c
#include<stdio.h>
#include<stdlib.h>
int main (void)
{
    FILE *fp=fopen("file.txt","w");
    char name[ 10] ="张三";
    char no[15]="20170304007";
    int age=17;
    if(NULL==fp)
    {
        printf ("Failed to open the file !\n");
        exit (0);
    }
    fprintf(fp,"%s\t%s\t%d\n",name,no,age);
    fclose(fp);
    return 0;
}
```

##### [5.按二进制方式读写数据块](#top) <b id="target5"></b>   
`接下来介绍按块读写数据的函数 fread 和 fwrite，这两个函数主要应用于对二进制文件的读写操作，不建议在文本文件中使用。接着介绍了 fread 读取二进制文件时，判断是否已经到达文件结尾的函数 feof。`

##### fread
`数据块读取（输入）函数 fread 的函数原型为：`

```c
#include<stdio.h>
unsigned fread (void *buf, unsigned size, unsigned count, FILE* fp);
```

`函数功能`：`从 fp 指向的文件中读取 count 个数据块，每个数据块的大小为 size。把读取到的数据块存放到 buf 指针指向的内存空间中。`

`返回值`：`返回实际读取的数据块（非字节）个数，如果该值比 count 小，则说明已读到文件尾或有错误产生。这时一般采用函数 feof 及 ferror 来辅助判断。`

`函数参数：`
* `buf`：`指向存放数据块的内存空间，该内存可以是数组空间，也可以是动态分配的内存。void类型指针，故可存放各种类型的数据，包括基本类型及自定义类型等。`
* `size`：`每个数据块所占的字节数。`
* `count`：`预读取的数据块最大个数。`
* `fp`：`文件指针，指向所读取的文件。`

##### fwrite
`数据块写入(输出）函数 fwrite 的函数原型为：`

```c
#include<stdio.h>
unsigned fwrite (const void *bufAunsigned size,unsigned count,FILE* fp);
```

`函数功能`：`将 buf 所指向内存中的 count 个数据块写入 fp 指向的文件中。每个数据块的大小为 size。`
`返回值`：`返回实际写入的数据块（非字节）个数，如果该值比 count 小，则说明 buf 所指空间中的所有数据块已写完或有错误产生。这时一般采用 feof 及 ferror 来辅助判断。`

`函数参数：`
* `buf`：`前加const的含义是buf所指的内存空间的数据块只读属性，避免程序中有意或无意的修改。`
* `size`：`每个数据块所占的字节数。`
* `count`：`预写入的数据块最大个数。`
* `fp`：`文件指针，指向所读取的文件。`

`注意：使用 fread 和 fwrite 对文件读写操作时，一定要记住使用“二进制模式”打开文件，否则，可能会出现意想不到的错误。`

##### feof
`操作文件时，经常使用 feof 函数来判断是否到达文件结尾。`

`feof 函数的函数原型为：`
```c
int feof (FILE * fp);
```
`函数功能：检查 fp 所关联文件流中的结束标志是否被置位，如果该文件的结束标志已被置位，返回非 0 值；否则，返回 0。`

##### [6.文件的随机读写](#top) <b id="target6"></b>    
`C 语言程序中常使用 rewind、fseek 函数移动文件读写位置指针。使用 ftell 获取当前文件读写位置指针。`

`函数 fseek 的函数原型为：`
```c
int fseek(FI：LE *fp, long offset, int origin);
```
`函数功能：把文件读写指针调整到从 origin 基点开始偏移 offset 处，即把文件读写指针移动到 origin+offset 处。`


`函数参数：`
* `origin`：`文件读写指针移动的基准点（参考点）。基准位置 origin 有三种常量取值：SEEK_SET、SEEK_CUR 和 SEEK_END，取值依次为 0，1，2。`
   * `SEEK_SET`:`文件开头，即第一个有效数据的起始位置。`
   * `SEEK_CUR`：`当前位置。`
   * `SEEK_END`:`文件结尾，即最后一个有效数据之后的位置。注意：此处并不能读取到最后一个有效数据，必须前移一个数据块所占的字节数，使该文件流的读写指针到达最后一个有效数据块的起始位置处。`

* `offset`：`位置偏移量，为 long 型，当 offset 为正整数时，表示从基准 origin 向后移动 offset 个字节的偏移；若 offset 为负数，表示从基准 origin 向前移动 |offset| 个字节的偏移。`

`返回值`：`成功，返回 0；失败，返回 -1。`

```c
//调用 fseek 函数时，第三个实参建议不要使用 0、1、2 等数字，最好使用可读性较强的常量符号形式，使用如下格式取代上面三条语句。
fseek(fp,10L,SEEK_SET);
fseek(fp,10L,SEEK_CUR);
fseek(fp,-20L,SEEK_END);
```

##### ftell
`函数 ftell 的函数原型：`

```c
long ftell (FILE *fp);
//所在头文件：<stdio.h>
```
`函数功能：用于获取当前文件读写指针相对于文件头的偏移字节数。`






--------------------
`作者:` `蒋星 JxKicker` 
`完成时间`:`2020年3月27日17:09:59`
`备注信息`: `任意使用` 
